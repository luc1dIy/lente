--+-- Size difference: 39%
--+-- Processing time: 46ms
--+-- Files packed   : 16
--+-- Packed at      : Wed, 03 Mar 2021 12:10:33 GMT
local a={}local b;local pcall,assert,c=pcall,assert,string.format;local d,e="luapack -- no such module '%s'","luapack -- error while requiring module '%s':\n%s"local function f(g)local h=a[g]if h~=nil then return h end;local i=b[g]assert(i~=nil,c(d,g))local j,k=pcall(i)assert(j,c(e,g,k))a[g]=k or true;return k end;b={a=function()end,b=function()local l={}l._name=nil;l._desc=nil;l._modType=nil;l._enabled=nil;l.__index=l;local m=f("k")local n=f("h")local o=f("d").modType;function l.new(p,q,o,r)local s=setmetatable({},l)s._name=p;s._desc=q;s._modType=o;s._ticks=r;s._enabled=false;m:registerMod(s)return s end;function l:getName()return self._name end;function l:getDesc()return self._desc end;function l:getType()return self._modType end;function l:isEnabled()return self._enabled end;function l:doesTick()return self._ticks end;function l:setCallback(t)self._callback=t end;function l:setTickCallback(t)self._tickCallback=t end;function l:run()if self._modType==o.passive then self._enabled=not self._enabled;n:updateMod(self)return end;self._callback(self)end;function l:tick()self._tickCallback(self)end;return l end,c=function()local u={}u._node=nil;u._default=nil;u._value=nil;u._allowed=nil;u.__index=u;local v=f("l")local assert,type=assert,type;local c=string.format;local w="! saved setting %s is of an illegal type: expected %s, got %s -- defaulting..."local x="expected %s, got %s."function u.new(y,z)local s=setmetatable({},u)s._node=y;s._default=z;s._value=s._default;s._allowed=type(s._default)local A=v:getValue(s._node)if A then local B=type(A)if B~=s._allowed then print(c(w,s._node,s._allowed,B))else s._value=A end end;v:updateValue(s._node,s._value)return s end;function u:getNode()return self._node end;function u:getValue()return self._value end;function u:setValue(k)local C=type(k)assert(C==self._allowed,c(x,self._allowed,C))self._value=k;v:updateValue(self._node,self._value)end;return u end,d=function()local D={}local function E(F,...)local G={}for H,p in pairs{...}do G[p]=H;G[H]=p end;D[F]=G end;E("modType","invoke","passive")return D end,e=function()return{order={"j","l"},requirements={"plethora:glasses","plethora:introspection","plethora:sensor","plethora:kinetic","plethora:keyboard"},side="back",configPath="config.json",tick=0.05,mods={"o","p","n"}}end,f=function()return{size=0.75,offset={x=10,y=10},palette={text=0xFFFFFFFF,enabled=0xbeed69ff,cursor=0xc0eae9ff,tracers=0xb4494940}}end,g=function()local I=f("e")local J,K=I.order,I.mods;local c=string.format;local L=c("> library %%i/%i",#J)local M=c("> mod %%i/%i",#K)local N=coroutine.wrap;print("$ pre-loading a few libraries...")local O=os.clock()for P=1,#J do f(J[P])print(c(L,P))end;print("$ loading mods...")for P=1,#K do f(K[P])print(c(M,P))end;print(c("$ loaded fully in %fs",os.clock()-O))local Q=f("i").processInput;local R=f("k"):getMods()local sleep,S=sleep,I.tick;local T=parallel.waitForAll;local U=os.pullEvent;local function V()for P=1,#R do local l=R[P]if l:doesTick()then l:tick()end end end;local function W()Q(U("key"))end;while true do T(V,W)end end,h=function()local n={}n._canvas=f("j").canvas()n._objects={}n._modMap={}n._current=nil;n._canvas.clear()local X=f("i")local u=f("c")local Y=f("f")local Z,_,a0=Y.palette,Y.offset,Y.size;local a1,a2,a3=Z.text,Z.enabled,Z.cursor;local D=f("d")local o=D.modType;local a4=f("m").trueLen;local select=select;local a5=n._canvas.addRectangle(_.x-2,_.y,1,5,a3)function n:addMod(l)local a6=self._canvas.addText({x=_.x,y=(a4(self._objects)+1)*_.y},l:getName(),a1,a0)a6.setShadow(true)self._objects[l]=a6;self._modMap[#self._modMap+1]=l;if a4(self._objects)==1 then self._current=1;self:updateCursor()end end;function n:updateMod(l)local a7=self._objects[l]if a7 then a7.setColour(l:isEnabled()and a2 or a1)end end;function n:updateCursor()if self._current then a5.setPosition(_.x-2,select(2,self._objects[self._modMap[self._current]].getPosition()))end end;function n._scrollUp()local a8=n._current-1;n._current=a8<1 and a4(n._objects)or a8;n:updateCursor()end;function n._scrollDown()local a9=n._current+1;n._current=a9>a4(n._objects)and 1 or a9;n:updateCursor()end;function n._runCursor()n._modMap[n._current]:run()end;X:registerKey(u.new("hud.scrollUp",keys.pageUp):getValue(),true,n._scrollUp)X:registerKey(u.new("hud.scrollDown",keys.pageDown):getValue(),true,n._scrollDown)X:registerKey(u.new("hud.runCursor",keys.grave):getValue(),true,n._runCursor)return n end,i=function()local X={}X._keys={}function X:registerKey(aa,ab,t)self._keys[#self._keys+1]={key=aa,ignoreHeld=ab,callback=t}end;function X.processInput(ac,aa,ad)for P=1,#X._keys do local ae=X._keys[P]if ae.key==aa and(ae.ignoreHeld and not ad)then ae.callback(aa,ad)end end end;return X end,j=function()local I=f("e")local af=I.requirements;local ag=peripheral.wrap(I.side)assert(ag,"! no neural interface detected.")local ah=ag.hasModule;assert(ah,"! peripheral is missing hasModule method? is this a neural interface?")for P=1,#af do local i=af[P]assert(ah(i),"! missing module: "..i)end;return ag end,k=function()local m={}m._mods={}local n=f("h")function m:getMods()return self._mods end;function m:registerMod(l)self._mods[#self._mods+1]=l;n:addMod(l)end;return m end,l=function()local ai=f("e").configPath;local v={}v._values={}local pcall=pcall;local aj,ak=textutils.serialiseJSON,textutils.unserialiseJSON;local c=string.format;local al=fs.open;function v:save()local j,am=pcall(al,ai,"w")if not j then print(c("! couldn't access config file?\n%s",am))return end;local j,an=pcall(am.write,am,aj(self._values))if not j then print(c("! failed to save config?\n%s",an))else am:close()end end;function v:load()local j,am=pcall(al,ai,"r")if not j then print(c("! couldn't access config file?\n%s",am))return end;if not am then print("! no config file found -- defaulting...")self:save()return end;local j,ao=pcall(am.readAll,am)if not j then print(c("! failed to read config?\n%s",ao))return end;local j,ap=pcall(ak,ao)if not j or not ap then print("! config file corrupted -- defaulting...")self:save()else self._values=ap end end;function v:getValue(y)return self._values[y]end;function v:updateValue(y,k)self._values[y]=k;self:save()end;v:load()return v end,m=function()local aq={}local ar,as=string.byte,string.sub;function aq.trueLen(at)local au=0;for ac,av in pairs(at)do au=au+1 end;return au end;function aq.getTotalBytes(aw)local ax=0;for P=1,#aw do ax=ax+ar(as(aw,P,P))end;return ax end;return aq end,n=function()local l=f("b")local D=f("d")local o=D.modType;local v=f("l")l.new("save_config","save the current config!",o.invoke):setCallback(function()v:save()end)l.new("load_config","load config from file!",o.invoke):setCallback(function()v:load()end)end,o=function()local l,u=f("b"),f("c")local D=f("d")local o=D.modType;local ay=f("j")local az,aA=ay.getMetaOwner,ay.launch;local aB=u.new("mods.movement.leap.power",2.5)local aC=u.new("mods.movement.leap.yawAmplifier",2.5)local aD=u.new("mods.movement.leap.pitchAmplifier",1.0)l.new("leap","propel yourself where you're looking!",o.invoke):setCallback(function()local aE=az()aA(aE.yaw*aC:getValue(),aE.pitch*aD:getValue(),aB:getValue())end)end,p=function()local l=f("b")local D=f("d")local o=D.modType;local ay=f("j")local am=ay.canvas3d()local aF=am.create()local aG=aF.recenter;local aH=aF.addLine;local aI=ay.sense;local a4=f("m").trueLen;local az=ay.getMetaOwner;local aJ=az().id;local aK=-0.078400001525879;local aL={0,-0.5,0}local aM=f("f").palette.tracers;local aN={}local function aO()for ac,aP in pairs(aN)do aP()end;aN={}end;local function aQ(aR)for aS,aP in pairs(aN)do if not aR[aS]then aP()end end end;l.new("tracers","trace foes down!",o.passive,true):setTickCallback(function(self)local aT=az()if not self:isEnabled()or aT.motionX==0 and(aT.motionY==aK or aT.motionY==0)and aT.motionZ==0 then if a4(aN)~=0 then aO()end;return end;aQ()aG(aL)local aU=aI()local aR={}for P=1,#aU do local aS=aU[P]if aS.id~=aJ then aN[aS]=aH(aL,{aS.x,aS.y,aS.z},3,aM).remove;aR[aS]=true end end end)end}return true
